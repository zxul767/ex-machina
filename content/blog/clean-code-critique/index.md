---
title: "Clean Code Revisited"
date: "2020-10-23T00:00:00.000"
description: "On the importance of keeping a critical mind"
---

In a [previous post](https://zxul767.dev/clean-code), I recommended the popular book [_Clean Code_](https://www.goodreads.com/book/show/3735293-clean-code). Since then I've noticed that the book has been criticized quite often in recent years (e.g., see [this post](https://qntm.org/clean)), so I took the time to review it again--it's been many years since I first read it--and I found that I do agree with some of the criticisms raised against it.

![Clean Code book cover.](./images/clean-code-cover.jpg)

Though I won't do a full review of the book here, I do want to point out a couple of issues with the book as a warning for less experienced developers:

+ Dogmatism
+ Bad Examples of _Clean Code_

## Dogmatism
Something you find when you read any book by Robert C. Martin is that he tends to be very entrenched in his opinions, sometimes almost dogmatic. You can notice this in his books ([The Clean Coder](https://www.goodreads.com/search?q=the+clean+coder&qid=), [Clean Architecture](https://www.goodreads.com/book/show/18043011-clean-architecture?ac=1&from_search=true&qid=r8wktTZU6q&rank=1), etc.), but also in [his talks](https://www.youtube.com/watch?v=7EmboKQH8lM&t=5006s) and other expositions in [social media](https://www.youtube.com/watch?v=KtHQGs3zFAM&t=884s) (e.g., _"Those who don't practice TDD cannot be considered professionals!"_)

He is, of course, entitled to have strong opinions and to argue passionately for what he believes in. But as engineers with a growth mindset, we should try to avoid becoming part of "engineering cults" and take his opinions with a grain of salt. As [Alan J. Perlis](https://en.wikipedia.org/wiki/Alan_Perlis) once wrote:

> Above all, I hope we don’t become missionaries. Don’t feel as if you’re Bible salesmen. The world has too many of those already. What you know about computing other people will learn. Don’t feel as if the key to successful computing is only in your hands. What’s in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.

Over time I've learned that listening to diverse opinions can give you a much stronger engineering foundation. From [Kent Beck](https://twitter.com/KentBeck)--known for popularizing the technique of [Test-Driven Development](https://zxul767.dev/tdd)--I learned that software development is almost always about trade-offs, not absolute rules. This means we must learn to see things in context and realize that "rules" are usually just "rules of thumb". 

Speaking of rules, one that stuck with me when I first read _Clean Code_ was that of "writing short functions that do one thing". In the beginning, I took it quite literally, and I strove to always reduce my functions to just a few lines of code even if, in retrospective, that sometimes hurt readability by creating too many levels of indirection or incoherent partitioning. As I'll try to show in the next section, it is easy to take the idea in that rule too far, usually with negative consequences.

## Bad Examples of Clean Code
To illustrate how taking rules quite literally can be disastrous sometimes, I'd like to reproduce an example from the book, and then comment on the refactoring that the author proposes.

The code in question is a program to generate a list of prime numbers (it is written in really unidiomatic Java style, but it's supposed to have been auto-generated by a tool):

```java
public class PrintPrimes {
    public static void main(String[] args) {
        final int M = 1000;
        final int RR = 50;
        final int CC = 4;
        final int WW = 10;
        final int ORDMAX = 30;
        int P[] = new int[M + 1];
        int PAGENUMBER, PAGEOFFSET, ROWOFFSET;
        int C, J, K;
        boolean JPRIME;
        int ORD, SQUARE, N;
        int MULT[] = new int[ORDMAX + 1];
        J = 1;
        K = 1; P[1] = 2; ORD = 2; SQUARE = 9;
        while (K < M) {
            do {
                J = J + 2;
                if (J == SQUARE) {
                    ORD = ORD + 1;
                    SQUARE = P[ORD] * P[ORD];
                    MULT[ORD - 1] = J;
                }
                N = 2;
                JPRIME = true;
                while (N < ORD && JPRIME) {
                    while (MULT[N] < J)
                        MULT[N] = MULT[N] + P[N] + P[N];
                    if (MULT[N] == J)
                        JPRIME = false;
                    N = N + 1;
                }
            } while (!JPRIME);
            K = K + 1;
            P[K] = J;
        }
        PAGENUMBER = 1;
        PAGEOFFSET = 1;
        while (PAGEOFFSET <= M) {
            System.out.println("The Prime Numbers --- Page " + PAGENUMBER);
            System.out.println("");
            for (ROWOFFSET = PAGEOFFSET; ROWOFFSET < PAGEOFFSET + RR; ROWOFFSET++) {
                for (C = 0; C < CC;C++)
                    if (ROWOFFSET + C * RR <= M)
                        System.out.format("%10d", P[ROWOFFSET + C * RR]);
                        System.out.println("");
            }
            System.out.println("\f");
            PAGENUMBER = PAGENUMBER + 1;
            PAGEOFFSET = PAGEOFFSET + RR * CC;
        }
    }

```

And here's the proposed refactoring in the book:

```java
public class PrimePrinter {
    public static void main(String[] args) {
        final int NUMBER_OF_PRIMES = 1000;
        int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);

        final int ROWS_PER_PAGE = 50;
        final int COLUMNS_PER_PAGE = 4;
        RowColumnPagePrinter tablePrinter =
            new RowColumnPagePrinter(
                ROWS_PER_PAGE, COLUMNS_PER_PAGE,
                "The First " + NUMBER_OF_PRIMES + " Prime Numbers");
        tablePrinter.print(primes);
    }
}
```

So far so good. The responsibility of generating the list of primes (`js•PrimeGenerator`) has been clearly separated from that of displaying them on the screen (`js•RowColumnPagePrinter`.) 

Let's have a look at the `js•RowColumnPagePrinter` class:

```java
public class RowColumnPagePrinter {
    private int rowsPerPage;
    private int columnsPerPage;
    private int numbersPerPage;
    private String pageHeader;
    private PrintStream printStream;

    public RowColumnPagePrinter(int rowsPerPage, int columnsPerPage, String pageHeader) {
        this.rowsPerPage = rowsPerPage;
        this.columnsPerPage = columnsPerPage;
        this.pageHeader = pageHeader;
        this.numbersPerPage = rowsPerPage * columnsPerPage;
        this.printStream = System.out;
    }
    public void print(int data[]) {
        int pageNumber = 1;
        for (int firstIndexOnPage = 0; // highlight-line
             firstIndexOnPage < data.length; // highlight-line
             firstIndexOnPage += numbersPerPage) { // highlight-line
            int lastIndexOnPage = Math.min(firstIndexOnPage + numbersPerPage - 1, data.length - 1);
            printPageHeader(pageHeader, pageNumber);
            printPage(firstIndexOnPage, lastIndexOnPage, data);
            printStream.println("\f");
            pageNumber++;
        }
    }
    private void printPage(int firstIndexOnPage, int lastIndexOnPage, int[] data) {
        int firstIndexOfLastRowOnPage = firstIndexOnPage + rowsPerPage - 1;
        for (int firstIndexInRow = firstIndexOnPage; // highlight-line
             firstIndexInRow <= firstIndexOfLastRowOnPage; // highlight-line
             firstIndexInRow++) { // highlight-line
            printRow(firstIndexInRow, lastIndexOnPage, data);
            printStream.println("");
        }
    }
    private void printRow(int firstIndexInRow, int lastIndexOnPage, int[] data) {
        for (int column = 0; column < columnsPerPage; column++) {
            int index = firstIndexInRow + column * rowsPerPage;
            if (index <= lastIndexOnPage)
                printStream.format("%10d", data[index]); }
    }
    private void printPageHeader(String pageHeader, int pageNumber) {
        printStream.println(pageHeader + " --- Page " + pageNumber);
        printStream.println("");
    }
}
```

Overall, this class reads reasonably well to me. One objection I have is whether we really need such long names (e.g., `js•firstIndexInRow` in the `js•printPage` function). One issue I find with overly verbose names is that they are harder to read, and can create unnatural line wrappings sometimes (here the `js•for` statement is broken into three lines as a consequence of trying to keep lines to 80 characters and using overly verbose names at the same time.)

The book itself offers some advice in this regard: _"the length of a variable name should be proportional to the size of its scope"_. In larger scopes we need more context, so longer names are useful; in shorter scopes, the surrounding context provides more information, so shorter names are enough (and longer names in that case usually just add unnecessary noise, which hurts readability.)

However, I will not fuss much about this particular issue because I'd like to focus on what I think is truly more problematic in the `js•PrimeGenerator` class.

Go ahead and spend some minutes trying to understand it before reading on.

```java
public class PrimeGenerator {
    private static int[] primes;
    private static ArrayList<Integer> multiplesOfPrimeFactors;

    protected static int[] generate(int n) {
        primes = new int[n];
        multiplesOfPrimeFactors = new ArrayList<Integer>();
        set2AsFirstPrime();
        checkOddNumbersForSubsequentPrimes();
        return primes;
    }
    private static void set2AsFirstPrime() {
        primes[0] = 2;
        multiplesOfPrimeFactors.add(2);
    }
    private static void checkOddNumbersForSubsequentPrimes() {
        int primeIndex = 1;
        for (int candidate = 3; primeIndex < primes.length; candidate += 2) {
            if (isPrime(candidate))
                primes[primeIndex++] = candidate;
        }
    }
    private static boolean isPrime(int candidate) {
        if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
            multiplesOfPrimeFactors.add(candidate);
            return false;
        }
        return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
    }
    private static boolean isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
        int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
        int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
        return candidate == leastRelevantMultiple;
    }
    private static boolean isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
        for (int n = 1; n < multiplesOfPrimeFactors.size(); n++) {
            if (isMultipleOfNthPrimeFactor(candidate, n))
                return false;
        }
        return true;
    }
    private static boolean isMultipleOfNthPrimeFactor(int candidate, int n) {
        return candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
    }
    private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
        int multiple = multiplesOfPrimeFactors.get(n);
        while (multiple < candidate)
            multiple += 2 * primes[n];
        multiplesOfPrimeFactors.set(n, multiple);
        return multiple;
    }
}
```

Did you understand clearly how and why it works? If you did without having prior context, I can only assume you're much smarter than me! For the rest of us, however, this class probably made us scratch our heads more than it should.

If we take the idea of "writing short functions that do one thing" quite literally, one could argue that _all_ of this code is good. But as we dig into it to truly understand its inner workings, very soon we notice quite a few problems. Let's dissect it method by method to see this:

```java
public class PrimeGenerator {
    private static int[] primes;
    private static ArrayList<Integer> multiplesOfPrimeFactors;

    protected static int[] generate(int n) {
        primes = new int[n];
        multiplesOfPrimeFactors = new ArrayList<Integer>();
        set2AsFirstPrime();
        checkOddNumbersForSubsequentPrimes();
        return primes;
    }
    private static void set2AsFirstPrime() {
        primes[0] = 2;
        multiplesOfPrimeFactors.add(2);
    }
    private static void checkOddNumbersForSubsequentPrimes() {
        int primeIndex = 1;
        for (int candidate = 3; primeIndex < primes.length; candidate += 2) {
            if (isPrime(candidate))
                primes[primeIndex++] = candidate;
        }
    }
    // ...
 }
```
These first few methods contain simple logic, but it's not obvious _why_ they're doing certain things. An explanation of the underlying algorithm is missing (e.g., what is the role of `js•multiplesOfPrimeFactors`?) Let's continue:

```java
public class PrimeGenerator {
    // ...
    private static boolean isPrime(int candidate) {
        if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) { // highlight-line
            multiplesOfPrimeFactors.add(candidate); // highlight-line
            return false; // highlight-line
        }
        return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
    }
    // ...
}
```

For me, this is where the head-scratching begins. The highlighted lines makes me feel like we've just taken a leap of logic:

+ What does "relevant multiple" mean and how does it relate to the "next larger prime factor"?
+ Why does this function have a side effect on `js•multiplesOfPrimeFactors` if its name suggests that it should be a [pure function](https://en.wikipedia.org/wiki/Pure_function)?

It seems like the author is hoping that the code will explain itself, but in this case it falls short of that goal. Any hope that the definition of "relevant" would be clarified in the next method is then lost:

```java
public class PrimeGenerator {
    // ...
    private static boolean isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
        int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
        int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
        return candidate == leastRelevantMultiple;
    }
    // ...
}
```

The implementation gives us some clues (e.g., a relevant multiple apparently has something to do with squares of primes), but the mere fact that we have to make conjectures is already a strong ["smell"](https://martinfowler.com/bliki/CodeSmell.html) in this code. 

The next method is straightforward and follows the [principle of least astonishment](https://wiki.c2.com/?PrincipleOfLeastAstonishment) well:

```java
public class PrimeGenerator {
    // ...
    private static boolean isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
        for (int n = 1; n < multiplesOfPrimeFactors.size(); n++) {
            if (isMultipleOfNthPrimeFactor(candidate, n))
                return false;
        }
        return true;
    }
    // ...
}
```

Unfortunately, the last two methods seem like they could have been just one, and the last one is doing some strange operations that are not explained at all by the name `js•smallestOddNthMultipleNotLessThanCandidate`:

```java
public class PrimeGenerator {
    // ...
    private static boolean isMultipleOfNthPrimeFactor(int candidate, int n) {
        return candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
    }
    private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
        int multiple = multiplesOfPrimeFactors.get(n);
        while (multiple < candidate)
            multiple += 2 * primes[n];
        multiplesOfPrimeFactors.set(n, multiple);
        return multiple;
    }
    // ...
}
```

When I first read the criticism of this example in [this post](https://qntm.org/clean), I was curious to see if the author was perhaps over exaggerating. He was not: I spent more than 15 minutes trying to grok the code, confused between the overly verbose names and the non-obvious implementation details, until I gave up and decided to read the original code to see if I could derive a more understandable refactoring.

Surprisingly, even though reading the original source was no walk in the park, it was more helpful in helping me realize that the code is an optimized version of the ["Sieve of Eratosthenes" algorithm](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), and that the most confusing bits are just due to the optimizations implemented.

Despite seemingly following "the rules" of "clean code", this code has fallen victim to a common problem when writing short functions: _forcing a "narrative" that is unnatural and hard to follow (partly due to the excessive indirection) simply in the name of creating very short functions._ This is, of course, not an issue with the principle itself, but rather with the programmer's ability to modularize the code appropriately, striking a balance between simplicity of part and coherence of the whole.

## Recapping the Issues
To recap, here are the problems I see with this example:

+ **Lack of Documentation**. The code fails to ease the reader into a nontrivial algorithm with documentation or comments that explain why some odd things are happening (i.e., the side effects in some methods).

+ **Verbosity**. The code uses overly verbose method names in an attempt to compensate for the lack of documentation (perhaps we can infer that overly verbose names is a "code smell"?)

+ **Forced Small Functions**. It seems to assume that many tiny functions always means better readability, but this is not true when the resulting partitioning causes excessive logical indirection, or when it is not cohesive (again, sometimes manifested as convoluted function names.)

The advice to write "short functions that do one thing" needs to be explained with more nuance. When followed literally, it is easy to arrive at code that is more difficult to understand than its everything-in-a-single-function counterpart.

There are two ends of a spectrum in this regard, both of which can be equally terrible. On the one hand, we can write everything in a single humongous function, mixing high and low-level details, and making it really difficult to separate core logic from implementation details. On the other hand, we can partition the code into extremely small functions that are quick to read at the individual level, but which make it harder to piece together the program as a whole.

There is an intrinsic difficulty in partitioning code with straightforward, intuitive boundaries that have clear inputs, outputs and side effects, which explains why, despite all good intentions, a refactoring attempt can sometimes still leave a lot of room for improvemement.

## A Proposed Refactoring
After studying the code and its underlying algorithm and optimizations in detail, I decided to take a stab at a refactoring to address the concerns I mentioned above. I wrote this version in Python but I don't think the choice of language is really a major factor in its improved clarity, as I'll comment below:

```python
# TODO: review whether the optimizations are truly worth the additional complexity
class PrimeGenerator:
    """
    Generates a list of the first `n` primes using the "sieve of Eratosthenes"
    algorithm (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) with some
    optimizations:

    1. Instead of directly testing candidate % prime == 0, we use repeated sums:
       prime + ... + prime + remainder == candidate (where remainder is zero if
       candidate % prime == 0 is true); hence `prime_multiples[i] == k*prime[i]`
       always holds for some integer `k`

    2. We start testing divisibility by `prime` at `prime^2` because
       smaller multiples will have already been considered by tests with
       smaller primes; hence the phrase "relevant multiple" in the method
       `add_next_relevant_prime_multiple_if_needed`
    """
    def generate(self, n):
        self.primes = [2, 3]
        self.prime_multiples = [2, 3]

        prime = 3
        for _ in range(n):
            prime = self._find_next_prime(prime)
            self.primes.append(prime)
        return self.primes

    def _find_next_prime(self, previous_prime):
        prime_candidate = previous_prime
        while True:
            prime_candidate += 2 # skip even numbers which cannot be primes
            self._add_next_relevant_prime_multiple_if_needed(prime_candidate)
            if not self._has_any_prime_divisor(prime_candidate):
                return prime_candidate

    def _add_next_relevant_prime_multiple_if_needed(self, prime_candidate):
        # If we're testing primality of N, we only need to test divisibility
        # with primes up to sqrt(N)
        # This is the bookkeeping to implement that optimization.
        m = len(self.prime_multiples)
        prime = self.primes[m] if m < len(self.primes) else 0
        if prime_candidate == prime * prime:
            self.prime_multiples.append(prime_candidate)

    def _has_any_prime_divisor(self, odd_number):
        return any(
            self._is_divisible_by_nth_prime(odd_number, n)
            # self.prime_multiples[0] (=2) is even, so we can skip its multiples
            for n in range(1, len(self.prime_multiples))
        )

    def _is_divisible_by_nth_prime(self, odd_number, n):
        # In the simplest version of the algorithm we would check:
        #   `number % prime[n] == 0`
        # but division can be expensive, so we instead use sums of `prime[n]`
        # to implicitly perform the division and figure out if the remainder
        # is zero. That is the role of `self.prime_multiples[n]`
        #
        # Notice also that we don't need to reset `self.prime_multiples[n]`
        # to `prime[n]` (or rather to `prime[n]*prime[n]`, since testing for
        # smaller multiples is redundant) because during prime generation we
        # test only increasingly larger numbers.
        while self.prime_multiples[n] < odd_number:
            # if self.prime_multiples[n] = 2k + 1 and self.prime[n] = 2m + 1:
            #    (2k + 1) + (2m + 1) = 2(k + m) + 2 = 2(k + m + 1)
            # thus `self.prime_multiples[n] + self.prime[n]` is even and we can
            # safely skip it
            self.prime_multiples[n] += self.primes[n] + self.primes[n]
        return self.prime_multiples[n] == odd_number

def compute_primes(n):
    return PrimeGenerator().generate(n)
```

While I don't claim this version is "perfect"--the `js•_is_divisible_by_nth_prime` method still has a side-effect, and the explanation of the optimizations is not detailed enough--I do hope you can agree that this version is likely to be significantly easier to understand for a future reader.

Using Python helps in making the code less verbose than its Java counterpart, but upon close examination, you'll realize that the true improvements are in the introductory documentation, the more adequate partitioning, and the comments that explain what the code cannot explain on its own.

If this was part of an actual codebase, I would definitely write a detailed post to explain how the optimizations work. With that, we could probably remove all the explanation comments, replacing them with just links to the corresponding sections in the documentation.

## Conclusion
While I still think that _Clean Code_ can be a useful book for many novice programmers (when read with a critical mind), I believe there are now several books and resources that can be just as useful to get a stronger foundation in techniques to write more maintainable code, and students or beginner programmers would do well to read them to get a well-rounded perspective.

Regardless of the books we read, however, the most important thing to keep in mind is that it's dangerous to follow "rules" blindly if we haven't fully understood its implications and limitations.

> Those who follow rules blindly are bound to eventually crash and burn

## Further Reading
The following resources are good alternatives and complements to _Clean Code_ if you're interested in learning more about this topic:

+ [99 Bottles of OOP](https://www.goodreads.com/book/show/31183020-99-bottles-of-oop) by [Sandi Metz](https://twitter.com/sandimetz?lang=en). This book explains the process of writing good code, covering pros and cons of various approaches while walking you through detailed code examples.

+ [Code Simplicity](https://www.goodreads.com/book/show/13234063-code-simplicity) by [Max Kanat-Alexander](https://twitter.com/mkanat?lang=en). This book is a compilation of many blog posts by the same author, where he exposes his theory of how complexity in software is the bane of all programmers, and encourages people to struggle to keep things simple.

+ [The Art of Readable Code](https://www.goodreads.com/book/show/8677004-the-art-of-readable-code) by [Dustin Boswell](https://twitter.com/dustinboswell?lang=en). Very similar in spirit to the _Clean Code_ book, worth reading for the additional insights and examples it presents.

+ [The Clean Code Talks](https://www.youtube.com/playlist?list=PLR5laMT-DcloGDcMKo07sEPZ7HvvD2Job). This is a series of talks by [Miško Hevery](https://twitter.com/mhevery), [Joshua Bloch](https://twitter.com/joshbloch) and present and former Googlers on "clean code" practices. While it doesn't cover many topics found in the books recommended above, it explores some other topics that are equally important when writing maintainable code.
  
